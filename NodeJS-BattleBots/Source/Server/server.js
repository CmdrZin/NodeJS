/* 
 * The MIT License
 *
 * Copyright 2020 CmdrZin.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sub-license, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/* *** Configure the HOST server. *** */
// Use the service PORT environment variable or 3000 if it is not set.
const port = process.env.PORT || 3000;
const io = require('socket.io')(port);
// Provides unique IDs
var nanoid = require("nanoid-esm");

// Set up an array for Players that is indexed by their network ID.
var players = [];

// Output a status messsge on the console.
console.log("BattleBot server listening on port " + port);

/* // TEST CODE
 var id = nanoid();
 console.log("ID assigned " + id);
 */

// Handle a Player connection.
/*
 * A 'socket' is established for each Client that connects.
 * So in essence, each io.on() is unique for each socket.
 */

io.on('connection', function (socket) {
    var thisPlayerID = nanoid(10);     //  generate a unique ID. Use only 10 char long.
    // Define a Player data structure to hold Player information.
    // Initialize data with default values.
    // We could randomize the starting position instead of always using the origin.
    var player = {
        id: thisPlayerID,
        color: 0,
        position: {
            x: 0, y: 0
        },
        force: {
            x: 0, y: 0
        },
        speed: 0,
        lastMoveTime: 0
    };
    // Add this player to the list of players.
    players[thisPlayerID] = player;

    console.log("Player connected. ID = ", thisPlayerID);
    // +++ Test CODE
//    console.log("Socket ID = ", socket.id);
    // ---

    // Let this Client know what their ID is by emitting a 'register' event.
    socket.emit('register', {id: thisPlayerID});

    // Stop here until the color message returns with the player's color.
    // Continue setup with the 'playerData' Event.

    /* *** These are the message handlers. *** */
    /*
     * These are unique handlers for this Socket connection. Each Socket will 
     * be unique, which is why thisPlayerId is maintained. It's for this socket.
     */

    //Player is reqesting to move. Calculate thier new position and broadcast it.
    /* 
     * JSONobject structure - Received
     * id:<string>       // the player ID generated by the server.
     * c:<JSONObject holding x:n and y:n>   // the player current position
     * d:<JSONObject holding x:n and y:n>   // the player's position position
     * 
     * JSONobject structure - Sent
     * id:<string>       // the player ID generated by the server.
     * x:<JSONObject holding x:n and y:n>   // the player new position
     * 
     * Examples
     * Player moving {"c":{"x":0,"y":0},"d":{"x":3.77125,"y":4.337967},"id":"ByWJcI5DD"}
     * Player moved {"id":"ByWJcI5DD","x":3.77125,"y":4.337967}
     */
    socket.on('move', function (data) {
        data.id = thisPlayerID;
        console.log('Player moving', JSON.stringify(data));
        /* DEBUG CODE
         console.log('socket ', socket.id);  // shows that each socket has it's own io.on().
         */

        // Update to their new position. This could be used later to check valid moves.
        player.position.x = data.d.x;
        player.position.y = data.d.y;

        delete data.c;       // remove from JSON object to reduce packet size.

        // These add and objects to the JSONObject by their declaration.
        data.x = data.d.x;
        data.y = data.d.y;

        delete data.d;       // remove from JSON object to reduce packet size.

        // Tell everyone to update there position information for this player.
        // The Clients will correctly parse this data since they expect id, x, y 
        // components. (see Network:OnMove())
        socket.broadcast.emit('move', data);
        // Note the different data structure in the printout.
        console.log('Player moved', JSON.stringify(data));
    });

    // The data packet only contains the position. The Player ID has to be added. 
    // before sending it to all Clients.
    socket.on('updatePosition', function (data) {
        console.log("Update Position: ", data);
        data.id = thisPlayerID;
        socket.broadcast.emit('updatePosition', data);
    });

    // The data packet contains Player data. 
    socket.on('newPlayerData', function (data) {
        console.log("Update New Player data: ", data);
        players[thisPlayerID].color = data.color;
        players[thisPlayerID].position.x = data.position.x;
        players[thisPlayerID].position.y = data.position.y;
        players[thisPlayerID].force.x = data.force.x;
        players[thisPlayerID].force.y = data.force.y;
        players[thisPlayerID].speed = data.speed;

        // Finish the new player process.
        console.log("Everyone spawn ", thisPlayerID);
        // Tell all of the connected Clients to Spawn a new player Avatar.
        socket.broadcast.emit('spawn', players[thisPlayerID]);
        // Tell all of the connected Clients to send their position using 'updatePosition' 
        // to the server. The server will then broadcast each of those position messages 
        console.log("Request everyones position");
        // to all of the Clients through it's socket.on('updatePosition', ...) handler.
        socket.broadcast.emit('requestPosition');

        console.log("New Player spawn everyone else");

        // Tell this Client to Spawn all of the other Players currently connected.
        for (var playerID in players) {
            if (playerID == thisPlayerID)
                continue;        // don't send spawn message to yourself.
            socket.emit('spawn', players[playerID]);
        }
    });

    socket.on('disconnect', function () {
        console.log('client disconected');
        delete players[thisPlayerID];
        socket.broadcast.emit('disconnected', {id: thisPlayerID});
    });

    /*
     * Other socket.on('message', function (data) { ... }); handlers can be added 
     * for more message types.
     * For each one, a corresponding Client generator is needed.
     */
});